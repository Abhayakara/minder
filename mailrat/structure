Mail is currently stored in a maildir, probably will change this later.
Mail other than absolute junk is generally not deleted, but falls off of the active list.
Mail is organized into topic lists.
Topic lists are versioned
One topic list, "all", lists all messages.
Each version of a topic list is sorted in order of receipt of the message
Versions are also ordered in time
Synchronization can be managed by finding the most recent common version, and collaborating to come up with a more recent common version that includes the changes made since the current common version.
Since the "all" list contains a list of all messages, it can be used by agents maintaining complete copies of the archive to identify new messages to fetch.
Since it is sorted by time, a copy of all recent messages can be maintained in the same way, for any value of "recent."

Python data structure:

dictionary of topics, keyed by name
each entry in the dictionary contains an array.   Each element of the array is a tuple; each tuple has three elements: the date of the version, the name of the version, and the contents of the version.   The array is sorted by date, with array[0] being the most recent version.   Version names consist of {machine-id}.{timestamp}.   {machine-id} has to be unique across all machines sharing copies of the database.   The contents of the version is an array, each element of which is a tuple, (message-id, date), the entire array sorted according to date, in reverse order.  message-id is the thing that the python maildir object uses to identify the message, which is a supposedly unique string.

It is worth noting that the way maildirs work isn't really adequate, and ultimately what we want is to identify each message by a message-id header field plus a timestamp.   Message-id header fields  aren't guaranteed to be unique, but the combination of a message-id and a timestamp based on time of receipt is very unlikely to be duplicated if the message is not a duplicate.   When message-id header fields match, irrespective of timestamp, the first step should be to see if the two messages are copies of the same message differing only in received: headers and other cruft; if so, the messages should get the same identifier by choosing one or the other timestamp.   Keeping two copies of the same message might be interesting for debugging purposes, but isn't likely to be useful to the user, so they should be presented as a single message.   If a message has no message-id, one can be generated by hashing the message.   Obviously for this to work the hash has to include only headers that aren't likely to change, plus the message body, possibly excluding well-known junk that's added to the body by list software.   Otherwise this disambiguation may not be possible in practice--something to think about.

Whether a message has been read is tracked by having a list of all not-yet-read messages.   Presumably more messages will not be on this list than on it, so it's more efficient than maintaining a list of read messages.

